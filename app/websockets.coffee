
# Multiplex multiple independent communications over a single websocket
# A routing key of one character is prepended to all outgoing messages
# to allow them to be routed on the server, and incoming messages are routed
# by their routing key, which is removed from the message
WSFactory = (urls, $websocket, $rootScope) ->

    websocketReconnectionDelay = 3000 # Attempt reconnect every 3 seconds

    log = Logger.get("websocket")
    ws  = undefined # Single websocket

    onOpenQ  = []
    onCloseQ = []
    onErrorQ = []
    routes   = {}

    reconnecting = false

    reconnect = ->
        reconnecting = true
        ws?.close()
        connect()

    connect = ->
        # Don't connect if connection is already complete
        if ws?.readyState == WebSocket.OPEN then return

        log.info("Websocket connecting...")
        ws = _.extend new $websocket(urls.websocket),

            onopen: (openEvent) ->
                log.info("Websocket connected")
                reconnecting = false
                for callback in onOpenQ
                    try
                        callback()
                    catch error
                        log.error "Error in websocket open handler ", error

            onclose: (closeEvent) ->
                # Ignore close events generated by our own deliberate reconnection
                if reconnecting then return

                for callback in onCloseQ
                    try
                        callback()
                    catch error
                        log.error "Error in websocket close handler ", error

                log.info("Websocket closed, reconnecting in #{websocketReconnectionDelay}ms")
                _.delay(connect, websocketReconnectionDelay)

            onerror: (errorEvent) ->
                for callback in onErrorQ
                    try
                        callback()
                    catch error
                        log.error "Error calling websocket error handling callback, original error #{errorEvent.message}", error
                unless ws.readyState == WebSocket.CLOSED
                    # Only display errors that occur when the websocket is connected
                    log.error("Websocket error: #{errorEvent.message}")

            onmessage: (frame) ->
                data    = frame.data
                splitAt = data.indexOf '|'
                if splitAt < 0 then throw 'Illegal frame: ' + data
                routingKey = data.substring(0, splitAt)
                message    = data.substring(splitAt + 1)
                callback   = routes[routingKey]
                if callback?
                    callback(message)
                else
                    log.warn("Unroutable message received at client: #{data}")

    # Reconnect whenever the user logs in or out
    if $rootScope and _.isFunction($rootScope.$on)
        $rootScope.$on 'loginSuccess',  reconnect
        $rootScope.$on 'logoutSuccess', reconnect

    # Connect immediately
    connect()

    {

        # Supplying a function to onOpen will cause it to be called
        # whenever the websocket is connected or reconnected.
        # Use to resubscribe to needed services
        onOpen: (fn) ->
            # If the connection is already open, call the function immediately
            if ws.readyState == WebSocket.OPEN
                fn()
            # Call the function every time the websocket connects or reconnects
            onOpenQ.push(fn)

        onClose: (fn) ->
            onCloseQ.push(fn)

        onError: (fn) ->
            onErrorQ.push(fn)

        # Route incoming messages from the websocket
        # Assumes incoming messages are of the form
        # routingKey|message
        addRoute: (routingKey, callback) ->
            if routes[routingKey]?
                throw "Attempt to claim already existing route #{routingKey}"
            routes[routingKey] = callback
            return {

                isOpen: -> ws.readyState == WebSocket.OPEN

                # Send a message to the websocket with this routing key
                send: (msg) ->
                    if ws.readyState == WebSocket.OPEN
                        #sendit = ->
                        ws.send(routingKey + '|' + msg)
                        #_.delay(sendit, 2000)
                    else
                        throw new Error "Cannot send because websocket is closed"

                # Remove this route
                # Call this method to avoid a memory leak
                close: -> routes[routingKey] = undefined
            }
    }

